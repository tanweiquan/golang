innodb默认的索引结构是B+树
聚集索引：主键索引，按B+树去找，找到主键id对应的数据是一行数据
二级索引（辅助索引）：按B+树去找，找到的key对应的数据是主键id
回表查询是先按二级索引拿到key，然后用key来进行聚集索引拿到一行数据
建立了索引后，会影响增、删、改的效率，因此不是索引越多越好。
当建立了索引后，索引速度最快，但当mysql评估索引比全表扫描还慢时，mysql则不使用索引。mysql评估走索引还是走全表扫描是看数据分布情况的，跟其他没关系。
索引语法：
创建索引：
             create  [unique|fulltext]  index  索引名称  on  表名(表中字段名,...);   
unique是唯一索引，fulltext是全文索引
索引名称的命名规范为：idx_表名_字段名
一个字段可以创建多个不同类型的索引
当使用多个字段名创建索引时，创建的索引是联合索引
创建联合索引时，字段的先后有要求的，要按表从左到右的字段来写：字段1，字段2，字段3
常规索引：create  index  索引名称  on  表名(字段名)；
建立有顺序的索引（优化order by）：create  index  索引名称  on  表名(字段1  顺序，字段2  顺序);
升序：asc        降序：desc

查看索引：
             show  index from 表名;
删除索引：
             drop index 索引名  on  表名;

性能分析：
sql优化主要是优化查询语句，而sql优化中索引占主要

可以通过以下指令来查看当前数据库的增删改查的访问频率：
                               show  global  status  like  'com_______';    ---->写7个下划线_，表示7个字符

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

查看哪些sql语句太慢：
1、慢查询日志：记录执行时间超过指定参数(long_query_time，默认10秒)的所有sql语句的日志。
查看没有开启慢查询日志：show  variables  like  'slow_query_log';
mysql默认是没有开启的，需要在配置文件(/etc/my.cnf)中配置如下信息：
#开启mysql慢查询开关
slow_query_log=1
#设置慢查询的时间为2秒，sql语句执行超过2秒，就视为慢查询，记录慢查询日志
log_query_time=2
设置完成后，重启mysql服务器，在shell命令行输入：systemctl  restart  mysqld
在linux中查看慢查询日志：cat  localhost-slow.log

2、profile详情
show  profiles 能够看到每条sql语句的执行耗时
have_profiling参数能够看当前mysql是否支持profile操作：  
                                  select  @@have_profiling;   ---->yes支持
默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：
                    查看是否开启：     select  @@profiling;
                          设置开启：     set profiling =1;
查看每一条sql耗时：show  profiles;
查看指定query_id的sql语句各阶段的耗时：show  profile  for  query  query_Id;  ----->query_Id是show  profiles;后查询得到的
查看指定query_id的sql语句cpu的使用情况：show  profile  cpu  for  query  query_Id; ----->query_Id是show  profiles;后查询得到的

3、explain 执行计划
explain或者desc命令获取mysql如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接顺序
语法：
直接在select语句前加上关键字explain/desc
explain  select  字段列表  from  表名  where  条件;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

索引使用 （索引一般用在where之后）
索引失效：
1、联合查询：
最左前缀法则： 
                    当索引了多列（联合索引），要遵守最左前缀法则。也就是查询从最左列开始，并且不跳过索引中间的列。
                    如果查询时，含最左列，但跳过了某一列，索引将会部分失效（跳过的字段以及后面的字段索引会失效）。
                    如果查询时，不含最左列，则索引全部失效，走全表扫描。
范围查询：
                   联合索引中，出现范围查询>或者<，范围查询右侧的列索引失效
                   规避方法：尽量使用>=或者<=这类的符号

2、适用全部的索引：
索引列上的运算：
                        不要在索引列上进行运算操作，否则索引失效。（这里的运算是指的是函数运算之类的运算）
字符串不加单引号：
                        字符串类型字段使用时，不加单引号，索引失效。
模糊查询： 
                        如果仅仅只是尾部模糊匹配，索引是不会失效。如果是头部模糊匹配，索引会失效。
                        如：select  * from user where  name = '周%';   --->索引成功
                              select  *  from user  where  name = '%利';  --->索引失效
or连接条件：
            用or分割开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及到的索引也不会用到。（一个字段有索引，一个字段没索引则涉及的索引也失效） 
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sql提示：当一个字段有多个索引时，可以给进行sql提示，让sql语句走哪个索引，不走哪个索引
                 
建议使用哪个索引：
                           use index(索引名称)：select  字段列表  from  表名  use  index(索引名称)  where  条件列表;

不使用哪个索引：
                       ignore index(索引名称)：select  字段列表  from  表名  ignore  index(索引名称)  where  条件列表;

必须使用哪个索引：
                         force index(索引名称)：select  字段列表  from  表名  force  index(索引名称)  where  条件列表;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
覆盖索引
覆盖索引：查询的时候使用到了索引，并且需要返回的列，在该索引中已经全部能够找到。
在使用二级索引时，尽量使用覆盖索引，避免使用select *，否则会导致回表查询（即当使用二级索引时，索引查询的分本索引列的列时，就会发生回表查询）
优化方法是给要查询的字段建立联合索引！二级索引拿到值的是主键id。
因此聚集索引真的棒！二级索引事真多！
判断使用单列索引还是联合索引：如果存在多个查询条件，则建议创建联合索引
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
前缀索引：
当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会导致索引变大，查询时，浪费大量的磁盘io，影响查询效率。
此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高效率。
语法：
            create index 索引名称  on  表名(字段名(n));    ------>n表示的是字段的值的前缀长度，要权衡前缀的重复性和索引的大小
