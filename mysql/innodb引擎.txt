innodb引擎
innodb是索引组织表。
innodb引擎的逻辑存储结构：
表空间--->段--->区--->页--->行
表空间(.ibd文件):一个mysql实例可以对应多个表空间，用于存放存储记录，索引等数据。
段：分为数据段(B+树的叶子节点)、索引段(B+树的非叶子节点)、回滚段。
区：每个区大小为1M。默认情况下innodb存储引擎的页大小为16k。即一个区一共有64个连续的页。
页：磁盘管理的最小单元。每个页16k，为保证页的连续性，innodb存储引擎每次从磁盘申请4~5个区。
行：innodb存储引擎数据是按行进行存放的。（行中存放着最后一次操作事务的id，回滚指针[通过回滚指针找到记录修改前的信息]，字段值。）

架构：innodb擅长事务处理，具有奔溃恢复的特性。
内存结构--------磁盘结构
######################################
内存结构
1、Buffer pool缓冲池：
在执行增删改查操作时，先操作缓冲池中的数据（若没有数据，则从磁盘中加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘io，加快处理速度。
缓冲池以页为单位，采用链表数据结构管理page。
page分类：
free page：空闲的page，未被使用。
clean page：被使用的page，数据没有被修改过。
dirty page：被使用的page，数据被修改过，与磁盘中的数据不一致。
2、Change Buffer更改缓冲区(在二级非唯一索引页中使用)：
在执行增删改操作时，如果数据不在缓冲池中，不会直接操作磁盘，而是将数据变更在更改缓冲区中，在未来数据被读取时，再将数据合并恢复到缓冲池中，再将合并后的数据刷新到磁盘中。
3、自适应哈希索引：系统监控表上各索引页的查询，如果观察到哈希索引可以提升速度，则会建立hash索引。参数adaptive_hash_index为开关。
4、Log Buffer日志缓冲区：用来保存要写入磁盘中的log日志数据(redo log、undo log)，默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要增删改许多行数据的事务，增加日志缓冲区的大小可以节省磁盘io。参数：innodb_log_buffer_size为缓冲区的大小。innodb_flush_log_at_trx_commit为日志刷新到磁盘的时机。

######################################
磁盘结构
1、系统表空间：是更改缓冲区的存储区域。
2、每个表的文件表空间包含单个innodb表的数据和索引，并存储在系统上的单个数据文件中。
3、通用表空间：通过create  tablespace语法创建通用表空间，在创建表时，可指定该表空间。
4、撤销表空间：mysql实例化时会自动创建两个默认的undo表空间（默认16M）,用于存储undo log日志。
5、innodb使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。
6、双写缓冲区：将数据页从缓冲池刷新到磁盘前，先将数据页写入双写缓冲区文件中。便于系统异常时恢复数据。
7、Redo Log重做日志：用来实现事务的持久性。由redo log buffer(重做日志缓冲，在内存中)以及redo log file(重做日志，在磁盘中)组成。当事务提交后会将所有修改信息放到该日志。用于在刷新脏页时发生了错误时进行数据恢复。
#####################################
事务原理：
事务是一组操作的集合，是不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么同时成功，要么同时失败。
ACID:
原子性：事务时不可分割的最小操作单元。要么同时成功，要么同时失败。
一致性：事务完成时，必须使所有的数据保持一致状态。
隔离性：数据库系统提供隔离机制，保证事务在不受外部并发操作影响的独立环境。事务之间互不影响。
持久性：事务一旦提交或回滚，它对数据库中的数据的改变是永久的。
保证ACID:
原子性、一致性、持久性：通过innodb底层的2个日志保证的：redo.log和undo log
隔离性：通过锁机制和MVCC来保证的

redo log:就是保证脏页刷新进行数据恢复，从而保证事务的持久性。（记录物理日志：数据）
undo  log：回滚日志，用于记录数据修改前的信息，存放在回滚段中。作用：提供回滚和MVCC(多版本并发控制)。（记录逻辑日志：操作）
redo log 在脏页正确刷新后会删除。undo log 在事务提交后并不会立即删除，而是检查是否后续需要用于MVCC。
##################################################
MVCC多版本并发控制：
指的是维护一个数据的多个版本。
概念：
1、当前读：
读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。(在增删改(自动)查(手动)中使用共享锁或排他锁时都是一种当前读。)【每次读都加锁】

2、快照读：
简单的select(不加锁)就是快照读。读取的是记录数据的可见版本，由可能是历史数据，不加锁，是非阻塞读。
在隔离级别下：
读提交：每次select，都生成一个快照读
可重复读：开启事务后的第一个select语句才是快照读的地方。
串行化：快照读会退化为当前读。

MVCC的实现原理：
数据记录中的三个隐式字段、undo log、Readview。
1、记录中的隐藏字段：
DB_TRX_ID：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。
DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log ，指向上一个版本。
DB_ROW_ID：隐藏主键，如果表结构没指定主键，将会生成该隐藏字段。
2、undo log：在增删改的时候产生的便于数据回滚的日志。
当执行的是insert语句时，产生的undo log只在回滚时需要，在事务提交后可被立即删除。
当执行的时update和delete语句时，产生的undo log不仅在回滚中需要，快照读时也需要，不会立即删除。
undo log版本链：不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条版本链表，链表表头是最新记录，链表尾部是最早旧记录。(最新-->最旧)
3、Readview：读视图是快照读sql执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。

访问最新记录还是访问undo log 版本链主要看四个核心字段：用历史记录的当前事务ID跟下面四个核心字段比对，
m_ids:当前活跃的事务ID集合                                                            【当前事务ID属于最小活跃和预分配事务ID之间且不在m_ids中时，可以访问该版本】--->说明数据已经提交。
min_trx_id：最小活跃事务ID {哪个事务先提交哪个最小，相反则时最大}【当前事务ID<min_trx_id时，可以访问该版本】--->说明数据已经提交。
max_trx_id：预分配事务ID，当前最大事务ID+1(因为事务ID是自增的)  【当前事务ID>max_trx_id时，不可以访问该版本】--->说明该事务是在Readview生成之后才开启的。
creator_trx_id：Readview创建者的事务ID                                         【当前事务ID=creator_trx_id时，可以访问该版本】--->说明数据是当前事务更改的。

生成Readview时机：
读提交：在事务中每执行一次快照读时(简单select)生成Readview
可重复读：仅在事务中第一次执行快照读时(简单select)生成Readview，后续复用该Readview。

总结事务ACID：
          原子性：undo log
          持久性：redo log
          一致性：undo log +redo log
          隔离性的实现：锁+MVCC(隐藏字段、undo log、ReadView)
          











